<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Farm Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background: #333; color: #fff; font-family: Arial, sans-serif; }
        canvas { display: block; background: #333; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Configurations
        const gpuConfigs = [
            { tier: 1, name: 'Gen1', cost: 500, hashrate: 50, power: 0.12, heat: 90, mtbf: 40 },
            { tier: 2, name: 'Gen2', cost: 1200, hashrate: 140, power: 0.28, heat: 200, mtbf: 60 },
            { tier: 3, name: 'Gen3', cost: 3000, hashrate: 400, power: 0.7, heat: 550, mtbf: 80 },
            { tier: 4, name: 'Gen4', cost: 7000, hashrate: 1100, power: 1.6, heat: 1200, mtbf: 100 },
            { tier: 5, name: 'Gen5', cost: 16000, hashrate: 2600, power: 3.6, heat: 2700, mtbf: 120 }
        ];
        const cracConfigs = [
            { tier: 'A', name: 'CRAC-A', cost: 4000, heatRemove: 2000, power: 0.6 },
            { tier: 'B', name: 'CRAC-B', cost: 10000, heatRemove: 6000, power: 1.8 }
        ];
        const trunkConfigs = [
            { tier: 1, name: 'T1', cost: 8000, kw: 20 },
            { tier: 2, name: 'T2', cost: 18000, kw: 60 },
            { tier: 3, name: 'T3', cost: 40000, kw: 200 }
        ];
        const rackConfigs = [
            { tier: 1, name: 'Rack-8', cost: 1000, slots: 8 }
        ]; // MVP: fixed 8 slots

        // State
        let state = {
            cash: 10000,
            displayCash: 10000,
            powerPrice: 0.11,
            coinPrice: 10000, // Assume realistic BTC-ish, adjust for balancing
            difficultyFactor: 1 / 10000, // To make revenue sensible
            powerUsed: 0,
            powerLimit: 0,
            heatUsed: 0,
            heatLimit: 0,
            heatStableTime: 0,
            gridWidth: 16,
            gridHeight: 12,
            grid: Array.from({length: 12}, () => Array(16).fill(null)), // entity id or null
            entities: [], // {id, type: 'rack'|'crac'|'trunk', x, y, tier, ...specific}
            nextEntityId: 0,
            time: {
                paused: false,
                speed: 1,
                lastUpdate: Date.now(),
                lastTick: Date.now(),
                gameTime: 0,
                lastSave: Date.now()
            },
            events: [],
            activeEvents: [],
            seed: Math.floor(Math.random() * 100000),
            buildMode: null, // {category, tier} or null
            currentTab: 'racks',
            selectedEntity: null,
            camera: { x: 0, y: 0, zoom: 1 },
            dragging: false,
            dragStart: {x:0, y:0},
            notifications: [],
            quests: [
                { id: 0, desc: 'Bring net profit to $1,000/hr', condition: () => state.netPerHour >= 1000, reward: 5000, completed: false },
                { id: 1, desc: 'Stabilize at â‰¤80% heat for 5 minutes', condition: () => state.heatStableTime >= 5, reward: 10000, completed: false }
            ],
            unlocks: { gpus: [1], cracs: ['A'], trunks: [1], racks: [1], gen4: false, gen5: false },
            tutorialStep: 0,
            tutorialSteps: [
                'Welcome! Start by placing a Power Trunk from Utilities tab.',
                'Now place a CRAC unit from Cooling tab.',
                'Place a Rack from Racks tab.',
                'Select GPUs tab, choose Gen1, then click on the rack to install.',
                'Watch your profit grow! Manage power and heat.'
            ]
        };

        // Center camera
        const tileW = 64;
        const tileH = 32;
        const gridCenterX = ((state.gridWidth / 2) - (state.gridHeight / 2)) * (tileW / 2);
        const gridCenterY = ((state.gridWidth / 2) + (state.gridHeight / 2)) * (tileH / 2);
        state.camera.x = -gridCenterX;
        state.camera.y = -gridCenterY;

        // Seeded RNG
        function seededRandom() {
            state.seed = (state.seed * 16807) % 2147483647;
            return (state.seed - 1) / 2147483646;
        }

        // Save/Load
        function saveState() {
            state.time.lastSave = Date.now();
            localStorage.setItem('gpuFarmState', JSON.stringify(state));
        }
        function loadState() {
            const saved = localStorage.getItem('gpuFarmState');
            if (saved) {
                state = JSON.parse(saved);
                const elapsedReal = (Date.now() - state.time.lastSave) / 1000;
                const capped = Math.min(elapsedReal, 12 * 3600);
                updateKPIs();
                if (state.netPerMin > 0) {
                    state.cash += state.netPerMin * capped;
                }
                state.time.lastSave = Date.now();
            } else {
                // Initial setup for new game
                const trunk = {id: state.nextEntityId++, type: 'trunk', x: 0, y: 0, tier: 1};
                state.entities.push(trunk);
                state.grid[0][0] = trunk.id;

                const crac = {id: state.nextEntityId++, type: 'crac', x: 1, y: 0, tier: 'A'};
                state.entities.push(crac);
                state.grid[0][1] = crac.id;

                const rack = {id: state.nextEntityId++, type: 'rack', x: 2, y: 0, tier: 1, slots: 8, gpus: Array(8).fill(null)};
                rack.gpus[0] = {tier: 1, failed: false};
                state.entities.push(rack);
                state.grid[0][2] = rack.id;

                state.cash -= (8000 + 4000 + 1000 + 500);
            }
        }
        loadState();
        setInterval(saveState, 30000);

        // Update KPIs
        function updateKPIs() {
            let totalHash = 0;
            let totalPower = 0;
            let totalHeat = 0;
            let totalHeatLimit = 0;
            let totalPowerLimit = 0;
            let coolingPower = 0;

            state.entities.forEach(ent => {
                if (ent.type === 'rack') {
                    ent.gpus.forEach(gpu => {
                        if (gpu && !gpu.failed) {
                            const config = gpuConfigs.find(c => c.tier === gpu.tier);
                            totalHash += config.hashrate;
                            totalPower += config.power;
                            totalHeat += config.heat;
                        }
                    });
                } else if (ent.type === 'crac') {
                    const config = cracConfigs.find(c => c.tier === ent.tier);
                    totalHeatLimit += config.heatRemove;
                    coolingPower += config.power;
                } else if (ent.type === 'trunk') {
                    const config = trunkConfigs.find(c => c.tier === ent.tier);
                    totalPowerLimit += config.kw;
                }
            });

            totalPower += coolingPower;
            state.powerUsed = totalPower;
            state.heatUsed = totalHeat;
            state.powerLimit = totalPowerLimit;
            state.heatLimit = totalHeatLimit;

            let heatMultiplier = totalHeat > 0 ? Math.min(1, totalHeatLimit / totalHeat) : 1;
            let powerMultiplier = totalPower > 0 ? Math.min(1, totalPowerLimit / totalPower) : 1;
            let throttle = Math.min(heatMultiplier, powerMultiplier);

            // Apply active events
            let effectivePowerPrice = state.powerPrice;
            let effectiveHeatLimit = totalHeatLimit;
            state.activeEvents.forEach(ev => {
                if (ev.type === 'surge') {
                    effectivePowerPrice *= ev.multiplier;
                } else if (ev.type === 'hotday') {
                    effectiveHeatLimit *= 0.8;
                }
            });
            heatMultiplier = totalHeat > 0 ? Math.min(1, effectiveHeatLimit / totalHeat) : 1;
            throttle = Math.min(heatMultiplier, powerMultiplier);

            const effectiveHash = totalHash * throttle;
            const revenuePerHour = effectiveHash * state.coinPrice * state.difficultyFactor;
            const costPerHour = totalPower * effectivePowerPrice;
            state.netPerHour = revenuePerHour - costPerHour;
            state.netPerMin = state.netPerHour / 60;
            state.revenuePerMin = revenuePerHour / 60;
            state.costPerMin = costPerHour / 60;

            // Unlocks (simplified)
            if (effectiveHash > 1000 && !state.unlocks.gpus.includes(2)) state.unlocks.gpus.push(2);
            if (state.netPerHour > 1000 && !state.unlocks.gpus.includes(3)) state.unlocks.gpus.push(3);
            // More for gen4,5
        }

        // Tick
        function tick() {
            state.gameTime += 1; // 1 min game
            updateKPIs();

            if (state.heatLimit > 0 && state.heatUsed / state.heatLimit <= 0.8) {
                state.heatStableTime++;
            } else {
                state.heatStableTime = 0;
            }

            // Economy
            state.cash += state.netPerMin;

            // Random walk on prices (per hour)
            if (state.gameTime % 60 === 0) {
                state.coinPrice *= 1 + (seededRandom() * 0.04 - 0.02);
                state.difficultyFactor *= 1 + (seededRandom() * 0.04 - 0.02);
            }

            // Events
            if (seededRandom() < 0.05) { // ~3/hr
                const eventType = Math.floor(seededRandom() * 5);
                let ev;
                switch (eventType) {
                    case 0: // GPU failure
                        const gpus = [];
                        state.entities.forEach(ent => {
                            if (ent.type === 'rack') ent.gpus.forEach((gpu, idx) => { if (gpu) gpus.push({ent, idx}); });
                        });
                        if (gpus.length > 0) {
                            const target = gpus[Math.floor(seededRandom() * gpus.length)];
                            target.ent.gpus[target.idx].failed = true;
                            target.ent.gpus[target.idx].repairTime = 5;
                            ev = {type: 'failure', entId: target.ent.id, gpuIdx: target.idx};
                            addNotification('GPU failure! Repair in 5 min or pay to fix.');
                        }
                        break;
                    case 1: // Power surge
                        ev = {type: 'surge', duration: 10, multiplier: 1.6 + seededRandom() * 0.6};
                        addNotification('Power price surge! Lasts 10 min.');
                        break;
                    case 2: // Hot day
                        ev = {type: 'hotday', duration: 60}; // 1 hour
                        addNotification('Hot day! Cooling -20% for 1 hour.');
                        break;
                    case 3: // Flash sale
                        const tier = Math.floor(seededRandom() * gpuConfigs.length) + 1;
                        ev = {type: 'sale', duration: 15, tier, discount: 0.25};
                        addNotification(`Flash sale on Gen${tier} GPUs! -25% for 15 min.`);
                        break;
                    case 4: // Another failure or something
                        break;
                }
                if (ev) state.activeEvents.push(ev);
            }

            // Process active events
            state.activeEvents = state.activeEvents.filter(ev => {
                if (ev.duration) ev.duration--;
                return ev.duration > 0;
            });

            // GPU failures probabilistic
            state.entities.forEach(ent => {
                if (ent.type === 'rack') {
                    ent.gpus.forEach((gpu, idx) => {
                        if (gpu && !gpu.failed) {
                            const config = gpuConfigs.find(c => c.tier === gpu.tier);
                            const prob = 1 / (config.mtbf * 60);
                            if (seededRandom() < prob) {
                                gpu.failed = true;
                                gpu.repairTime = 5;
                                addNotification('GPU failure! Repair in 5 min or pay to fix.');
                            }
                        } else if (gpu && gpu.failed) {
                            gpu.repairTime--;
                            if (gpu.repairTime <= 0) {
                                gpu.failed = false;
                            }
                        }
                    });
                }
            });

            // Quests
            state.quests.forEach(q => {
                if (!q.completed && q.condition()) {
                    q.completed = true;
                    state.cash += q.reward;
                    addNotification(`Quest completed: ${q.desc} Reward: $${q.reward}`);
                }
            });
        }

        // Add notification
        function addNotification(msg) {
            state.notifications.push({msg, time: Date.now()});
            if (state.notifications.length > 5) state.notifications.shift();
        }

        // Rendering
        function gridToScreen(gridX, gridY) {
            const isoX = (gridX - gridY) * (tileW / 2);
            const isoY = (gridX + gridY) * (tileH / 2);
            return {
                x: canvas.width / 2 + isoX * state.camera.zoom + state.camera.x,
                y: canvas.height / 2 + isoY * state.camera.zoom + state.camera.y
            };
        }

        function screenToGrid(screenX, screenY) {
            const relX = (screenX - canvas.width / 2 - state.camera.x) / state.camera.zoom;
            const relY = (screenY - canvas.height / 2 - state.camera.y) / state.camera.zoom;
            const gridX = Math.floor((relX / (tileW / 2) + relY / (tileH / 2)) / 2);
            const gridY = Math.floor((relY / (tileH / 2) - relX / (tileW / 2)) / 2);
            return {x: gridX, y: gridY};
        }

        function drawDiamond(x, y, color) {
            ctx.beginPath();
            ctx.moveTo(x, y - tileH / 2);
            ctx.lineTo(x + tileW / 2, y);
            ctx.lineTo(x, y + tileH / 2);
            ctx.lineTo(x - tileW / 2, y);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#aaa';
            ctx.stroke();
        }

        function drawEntity(ent, sx, sy) {
            if (ent.type === 'rack') {
                ctx.fillStyle = '#777';
                ctx.fillRect(sx - 20, sy - 40, 40, 40); // Simple box
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.fillText(`Rack (${ent.gpus.filter(g => g).length}/${ent.slots})`, sx - 30, sy + 50);
            } else if (ent.type === 'crac') {
                ctx.fillStyle = '#00f';
                ctx.fillRect(sx - 15, sy - 30, 30, 30);
            } else if (ent.type === 'trunk') {
                ctx.fillStyle = '#f00';
                ctx.fillRect(sx - 15, sy - 30, 30, 30);
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Grid
            for (let gy = 0; gy < state.gridHeight; gy++) {
                for (let gx = 0; gx < state.gridWidth; gx++) {
                    const pos = gridToScreen(gx, gy);
                    drawDiamond(pos.x, pos.y, state.grid[gy][gx] ? '#777' : '#555');
                }
            }

            // Entities
            state.entities.forEach(ent => {
                const pos = gridToScreen(ent.x, ent.y);
                drawEntity(ent, pos.x, pos.y);
            });

            // Ghost
            if (state.buildMode && state.buildMode.category !== 'gpus') {
                const mouseGrid = screenToGrid(mouseX, mouseY);
                if (mouseGrid.x >= 0 && mouseGrid.x < state.gridWidth && mouseGrid.y >= 0 && mouseGrid.y < state.gridHeight && !state.grid[mouseGrid.y][mouseGrid.x]) {
                    const pos = gridToScreen(mouseGrid.x, mouseGrid.y);
                    ctx.globalAlpha = 0.5;
                    drawDiamond(pos.x, pos.y, '#0f0');
                    ctx.globalAlpha = 1;
                }
            }

            // HUD (top)
            ctx.fillStyle = '#0008';
            ctx.fillRect(0, 0, canvas.width, 50);
            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            state.displayCash += (state.cash - state.displayCash) * 0.1; // Tween
            ctx.fillText(`Cash: $${Math.floor(state.displayCash).toLocaleString()}`, 10, 20);
            ctx.fillText(`Net/hr: $${Math.floor(state.netPerHour || 0).toLocaleString()}`, 200, 20);
            ctx.fillText(`Power: ${(state.powerUsed || 0).toFixed(1)}/${state.powerLimit} kW`, 400, 20);
            ctx.fillText(`Heat: ${state.heatUsed || 0}/${state.heatLimit || 0} BTU/h`, 600, 20);

            // Time controls
            const speedText = state.time.paused ? 'Paused' : `x${state.time.speed}`;
            ctx.fillText(speedText, canvas.width - 100, 20);

            // Build panel left
            ctx.fillStyle = '#0008';
            ctx.fillRect(0, 50, 200, canvas.height - 50);
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            const tabs = ['Racks', 'GPUs', 'Cooling', 'Utilities'];
            tabs.forEach((tab, i) => {
                ctx.fillStyle = state.currentTab === tab.toLowerCase() ? '#fff' : '#aaa';
                ctx.fillText(tab, 10, 80 + i * 30);
            });

            let items = [];
            switch (state.currentTab) {
                case 'racks':
                    items = rackConfigs.map(c => ({name: c.name, cost: c.cost, tier: c.tier, category: 'racks'}));
                    break;
                case 'gpus':
                    items = gpuConfigs.filter(g => state.unlocks.gpus.includes(g.tier)).map(g => ({name: g.name, cost: g.cost, tier: g.tier, category: 'gpus'}));
                    break;
                case 'cooling':
                    items = cracConfigs.filter(c => state.unlocks.cracs.includes(c.tier)).map(c => ({name: c.name, cost: c.cost, tier: c.tier, category: 'cooling'}));
                    break;
                case 'utilities':
                    items = trunkConfigs.filter(t => state.unlocks.trunks.includes(t.tier)).map(t => ({name: t.name, cost: t.cost, tier: t.tier, category: 'utilities'}));
                    break;
            }

            ctx.fillStyle = '#fff';
            let itemY = 200;
            items.forEach((item, i) => {
                ctx.fillText(`${item.name} $${item.cost}`, 10, itemY + i * 30);
            });

            // Inspect panel right
            if (state.selectedEntity) {
                ctx.fillStyle = '#0008';
                ctx.fillRect(canvas.width - 200, 50, 200, canvas.height - 50);
                ctx.fillStyle = '#fff';
                const ent = state.selectedEntity;
                ctx.fillText(`${ent.type.toUpperCase()} Tier ${ent.tier}`, canvas.width - 190, 70);
                if (ent.type === 'rack') {
                    ctx.fillText(`GPUs: ${ent.gpus.filter(g => g).length}/${ent.slots}`, canvas.width - 190, 90);
                    ent.gpus.forEach((gpu, i) => {
                        if (gpu) {
                            ctx.fillText(`Slot ${i+1}: Gen${gpu.tier} ${gpu.failed ? '(Failed)' : ''}`, canvas.width - 190, 110 + i*20);
                        }
                    });
                }
            }

            // Notifications bottom
            ctx.fillStyle = '#0008';
            ctx.fillRect(0, canvas.height - 150, canvas.width, 150);
            ctx.fillStyle = '#fff';
            state.notifications.forEach((n, i) => {
                ctx.fillText(n.msg, 10, canvas.height - 130 + i * 20);
            });

            // Tutorial
            if (state.tutorialStep < state.tutorialSteps.length) {
                ctx.fillStyle = '#000a';
                ctx.fillRect(100, 100, canvas.width - 200, 100);
                ctx.fillStyle = '#fff';
                ctx.fillText(state.tutorialSteps[state.tutorialStep], 120, 150);
            }
        }

        // Game loop
        let lastFrame = Date.now();
        function loop() {
            const now = Date.now();
            let delta = now - lastFrame;
            lastFrame = now;

            if (!state.time.paused) {
                let tickInterval = 1000 / state.time.speed;
                state.time.lastTick += delta;
                while (state.time.lastTick >= tickInterval) {
                    tick();
                    state.time.lastTick -= tickInterval;
                }
            }

            render();
            requestAnimationFrame(loop);
        }
        loop();

        // Input
        let mouseX = 0, mouseY = 0;
        canvas.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            if (state.dragging) {
                state.camera.x = mouseX - state.dragStart.x;
                state.camera.y = mouseY - state.dragStart.y;
            }
        });

        canvas.addEventListener('mousedown', e => {
            if (e.button === 0) {
                mouseX = e.clientX;
                mouseY = e.clientY;
                // Time controls
                if (mouseX > canvas.width - 100 && mouseY < 50) {
                    if (state.time.paused) {
                        state.time.paused = false;
                        state.time.speed = 1;
                    } else if (state.time.speed === 1) {
                        state.time.speed = 2;
                    } else if (state.time.speed === 2) {
                        state.time.speed = 4;
                    } else if (state.time.speed === 4) {
                        state.time.paused = true;
                    }
                    return;
                }

                // Build panel
                if (mouseX < 200 && mouseY > 50) {
                    if (mouseY >= 80 && mouseY < 200) {
                        const tabIndex = Math.floor((mouseY - 80) / 30);
                        if (tabIndex >= 0 && tabIndex < tabs.length) {
                            state.currentTab = tabs[tabIndex].toLowerCase();
                        }
                    } else if (mouseY >= 200) {
                        const itemIndex = Math.floor((mouseY - 200) / 30);
                        // items defined in render, but need to recompute here
                        let items = [];
                        switch (state.currentTab) {
                            case 'racks':
                                items = rackConfigs.map(c => ({tier: c.tier}));
                                break;
                            case 'gpus':
                                items = gpuConfigs.filter(g => state.unlocks.gpus.includes(g.tier)).map(g => ({tier: g.tier}));
                                break;
                            case 'cooling':
                                items = cracConfigs.filter(c => state.unlocks.cracs.includes(c.tier)).map(c => ({tier: c.tier}));
                                break;
                            case 'utilities':
                                items = trunkConfigs.filter(t => state.unlocks.trunks.includes(t.tier)).map(t => ({tier: t.tier}));
                                break;
                        }
                        if (itemIndex >= 0 && itemIndex < items.length) {
                            state.buildMode = {category: state.currentTab, tier: items[itemIndex].tier};
                        }
                    }
                    return;
                }

                // Inspect panel clicks (stretch)
                if (mouseX > canvas.width - 200 && state.selectedEntity) {
                    // Add logic for buttons if implemented
                    return;
                }

                // Notifications (stretch)
                if (mouseY > canvas.height - 150) {
                    return;
                }

                // Grid click
                const gridPos = screenToGrid(mouseX, mouseY);
                if (gridPos.x >= 0 && gridPos.x < state.gridWidth && gridPos.y >= 0 && gridPos.y < state.gridHeight) {
                    const entId = state.grid[gridPos.y][gridPos.x];
                    if (entId !== null) {
                        state.selectedEntity = state.entities.find(e => e.id === entId);
                        if (state.buildMode && state.buildMode.category === 'gpus' && state.selectedEntity.type === 'rack') {
                            // Install GPU
                            const rack = state.selectedEntity;
                            const emptySlot = rack.gpus.findIndex(g => !g);
                            if (emptySlot !== -1) {
                                const config = gpuConfigs.find(c => c.tier === state.buildMode.tier);
                                let cost = config.cost;
                                state.activeEvents.forEach(ev => {
                                    if (ev.type === 'sale' && ev.tier === state.buildMode.tier) cost *= (1 - ev.discount);
                                });
                                if (state.cash >= cost) {
                                    state.cash -= cost;
                                    rack.gpus[emptySlot] = {tier: state.buildMode.tier, failed: false};
                                    state.tutorialStep = Math.min(state.tutorialStep + 1, state.tutorialSteps.length);
                                }
                            }
                        }
                    } else if (state.buildMode && state.buildMode.category !== 'gpus') {
                        // Place entity
                        let config, type;
                        switch (state.buildMode.category) {
                            case 'racks':
                                config = rackConfigs.find(c => c.tier === state.buildMode.tier);
                                type = 'rack';
                                break;
                            case 'cooling':
                                config = cracConfigs.find(c => c.tier === state.buildMode.tier);
                                type = 'crac';
                                break;
                            case 'utilities':
                                config = trunkConfigs.find(c => c.tier === state.buildMode.tier);
                                type = 'trunk';
                                break;
                        }
                        if (config && state.cash >= config.cost) {
                            state.cash -= config.cost;
                            const ent = {id: state.nextEntityId++, type, x: gridPos.x, y: gridPos.y, tier: state.buildMode.tier};
                            if (type === 'rack') {
                                ent.slots = config.slots;
                                ent.gpus = Array(ent.slots).fill(null);
                            }
                            state.entities.push(ent);
                            state.grid[gridPos.y][gridPos.x] = ent.id;
                            state.tutorialStep = Math.min(state.tutorialStep + 1, state.tutorialSteps.length);
                        }
                    }
                } else {
                    // Start drag
                    state.dragging = true;
                    state.dragStart = {x: mouseX - state.camera.x, y: mouseY - state.camera.y};
                }
            }
        });

        canvas.addEventListener('mouseup', e => {
            state.dragging = false;
        });

        canvas.addEventListener('wheel', e => {
            const zoomDelta = e.deltaY < 0 ? 0.1 : -0.1;
            state.camera.zoom = Math.max(0.5, Math.min(2, state.camera.zoom + zoomDelta));
        });

        // Keyboard
        document.addEventListener('keydown', e => {
            const speed = 10;
            if (e.key === 'w' || e.key === 'W') state.camera.y += speed;
            if (e.key === 's' || e.key === 'S') state.camera.y -= speed;
            if (e.key === 'a' || e.key === 'A') state.camera.x += speed;
            if (e.key === 'd' || e.key === 'D') state.camera.x -= speed;
            if (e.key === ' ') state.time.paused = !state.time.paused;
            // More keys
        });

        // Sounds (simple beep)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playBeep() {
            const osc = audioCtx.createOscillator();
            osc.type = 'square';
            osc.frequency.setValueAtTime(440, audioCtx.currentTime);
            osc.connect(audioCtx.destination);
            osc.start();
            setTimeout(() => osc.stop(), 100);
        }

        // Call playBeep on placement etc.

    </script>
</body>
</html>