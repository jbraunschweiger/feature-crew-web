<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Generator & Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            overflow: hidden;
            background: #000;
        }
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        /* Control Panel */
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            color: #fff;
            width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 1000;
        }
        
        #controls h2 {
            margin-bottom: 20px;
            color: #4fc3f7;
            font-size: 24px;
            text-shadow: 0 0 20px rgba(79, 195, 247, 0.5);
        }
        
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        .control-group h3 {
            color: #81c784;
            margin-bottom: 12px;
            font-size: 16px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #b0bec5;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        select {
            width: 100%;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            color: #fff;
            margin-bottom: 10px;
        }
        
        .stat-display {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
        }
        
        .stat-display span {
            color: #ffd54f;
            font-weight: bold;
        }
        
        /* Info Panel */
        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            color: #fff;
            min-width: 200px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        #info-panel h3 {
            color: #4fc3f7;
            margin-bottom: 10px;
        }
        
        .info-item {
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .info-item span {
            color: #ffd54f;
            font-weight: bold;
        }
        
        /* Loading Screen */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4fc3f7;
            font-size: 24px;
            text-align: center;
            z-index: 2000;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(79, 195, 247, 0.3);
            border-top: 3px solid #4fc3f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 30, 0.95);
            padding: 10px 20px;
            border-radius: 8px;
            color: #b0bec5;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="loading">
        <div>Generating City...</div>
        <div class="loading-spinner"></div>
    </div>
    
    <div id="controls">
        <h2>üèôÔ∏è City Controls</h2>
        
        <div class="control-group">
            <h3>Generation</h3>
            <button onclick="cityGen.generateNewCity()">üé≤ Generate New City</button>
            <button onclick="cityGen.toggleSimulation()">‚èØÔ∏è Toggle Simulation</button>
            <label>City Size: <span id="sizeValue">50</span></label>
            <input type="range" id="citySize" min="30" max="100" value="50" step="10">
            <label>Building Density: <span id="densityValue">0.7</span></label>
            <input type="range" id="density" min="0.3" max="1" value="0.7" step="0.1">
        </div>
        
        <div class="control-group">
            <h3>Environment</h3>
            <label>Time of Day: <span id="timeValue">12:00</span></label>
            <input type="range" id="timeOfDay" min="0" max="24" value="12" step="0.1">
            <label>Weather:</label>
            <select id="weather">
                <option value="clear">‚òÄÔ∏è Clear</option>
                <option value="rain">üåßÔ∏è Rain</option>
                <option value="fog">üå´Ô∏è Fog</option>
                <option value="snow">‚ùÑÔ∏è Snow</option>
            </select>
            <button onclick="cityGen.toggleDayNightCycle()">üåÖ Auto Day/Night</button>
        </div>
        
        <div class="control-group">
            <h3>Simulation</h3>
            <label>Traffic Density: <span id="trafficValue">50</span></label>
            <input type="range" id="trafficDensity" min="10" max="200" value="50" step="10">
            <label>Simulation Speed: <span id="speedValue">1x</span></label>
            <input type="range" id="simSpeed" min="0.5" max="3" value="1" step="0.5">
            <button onclick="cityGen.toggleTraffic()">üöó Toggle Traffic</button>
        </div>
        
        <div class="control-group">
            <h3>Camera</h3>
            <button onclick="cityGen.resetCamera()">üì∑ Reset View</button>
            <button onclick="cityGen.toggleCameraMode()">üîÑ Change View Mode</button>
        </div>
        
        <div class="control-group">
            <h3>Statistics</h3>
            <div class="stat-display">
                Population: <span id="population">0</span>
            </div>
            <div class="stat-display">
                Buildings: <span id="buildingCount">0</span>
            </div>
            <div class="stat-display">
                Traffic: <span id="vehicleCount">0</span>
            </div>
            <div class="stat-display">
                Economic Activity: <span id="economy">0</span>%
            </div>
        </div>
    </div>
    
    <div id="info-panel">
        <h3>City Info</h3>
        <div class="info-item">District: <span id="currentDistrict">Downtown</span></div>
        <div class="info-item">FPS: <span id="fps">60</span></div>
        <div class="info-item">Time: <span id="currentTime">12:00</span></div>
    </div>
    
    <div id="instructions">
        üñ±Ô∏è Left Click + Drag: Rotate | Right Click + Drag: Pan | Scroll: Zoom | Keys: WASD/Arrows to move
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script>
        class CityGenerator {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.simplex = new SimplexNoise();
                
                this.citySize = 50;
                this.gridSize = 100;
                this.blockSize = 10;
                this.buildingDensity = 0.7;
                this.buildings = [];
                this.vehicles = [];
                this.pedestrians = [];
                this.lights = [];
                this.roads = [];
                this.districts = [];
                this.particles = [];
                this.parks = [];
                
                this.simulationRunning = true;
                this.dayNightCycle = false;
                this.trafficEnabled = true;
                this.timeOfDay = 12;
                this.weather = 'clear';
                this.simulationSpeed = 1;
                
                this.population = 0;
                this.economicActivity = 75;
                
                this.cameraMode = 'orbit';
                this.cameraAngle = 0;
                this.cameraDistance = 100;
                this.cameraHeight = 50;
                this.cameraTarget = new THREE.Vector3(0, 0, 0);
                
                this.mouse = { x: 0, y: 0, isDown: false, button: 0 };
                this.keys = {};
                
                this.clock = new THREE.Clock();
                this.lastTime = 0;
                this.fps = 0;
                
                this.init();
            }
            
            init() {
                // Renderer setup
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                // Scene setup
                this.scene.fog = new THREE.Fog(0x4a5568, 50, 300);
                
                // Camera setup
                this.camera.position.set(80, 60, 80);
                this.camera.lookAt(0, 0, 0);
                
                // Lighting
                this.setupLighting();
                
                // Generate city
                this.generateCity();
                
                // Setup controls
                this.setupControls();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
                
                // Start animation
                this.animate();
            }
            
            setupLighting() {
                // Ambient light
                this.ambientLight = new THREE.AmbientLight(0x4a5568, 0.4);
                this.scene.add(this.ambientLight);
                
                // Directional light (sun)
                this.sunLight = new THREE.DirectionalLight(0xffffff, 1);
                this.sunLight.position.set(50, 100, 50);
                this.sunLight.castShadow = true;
                this.sunLight.shadow.camera.left = -100;
                this.sunLight.shadow.camera.right = 100;
                this.sunLight.shadow.camera.top = 100;
                this.sunLight.shadow.camera.bottom = -100;
                this.sunLight.shadow.camera.near = 0.1;
                this.sunLight.shadow.camera.far = 200;
                this.sunLight.shadow.mapSize.width = 2048;
                this.sunLight.shadow.mapSize.height = 2048;
                this.scene.add(this.sunLight);
                
                // Hemisphere light for better ambient
                this.hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x545454, 0.6);
                this.scene.add(this.hemiLight);
            }
            
            generateCity() {
                // Clear existing city
                this.clearCity();
                
                // Generate terrain
                this.generateTerrain();
                
                // Generate districts with density map
                this.generateDistricts();
                
                // Generate road network
                this.generateRoads();
                
                // Generate parks (before buildings to reserve space)
                this.generateParks();
                
                // Generate buildings based on districts
                this.generateBuildings();
                
                // Generate vehicles
                this.generateVehicles();
                
                // Generate pedestrians
                this.generatePedestrians();
                
                // Update stats
                this.updateStats();
            }
            
            generateTerrain() {
                const geometry = new THREE.PlaneGeometry(this.gridSize * 2, this.gridSize * 2, 50, 50);
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0x2d3436,
                    side: THREE.DoubleSide 
                });
                
                // Add very subtle noise to terrain
                const vertices = geometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    const y = vertices[i + 1];
                    // Check if near a road (every 10 units)
                    const nearRoad = (Math.abs(x % 10) < 2 || Math.abs(y % 10) < 2);
                    if (!nearRoad) {
                        vertices[i + 2] = this.simplex.noise2D(x * 0.01, y * 0.01) * 0.3;
                    } else {
                        vertices[i + 2] = -0.05; // Slightly lower under roads
                    }
                }
                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
                
                const terrain = new THREE.Mesh(geometry, material);
                terrain.rotation.x = -Math.PI / 2;
                terrain.receiveShadow = true;
                this.scene.add(terrain);
            }
            
            generateDistricts() {
                // Define comprehensive district types
                this.districtTypes = {
                    financial: { 
                        name: 'Financial', 
                        color: 0x1a237e, 
                        buildingHeight: { min: 35, max: 70 }, 
                        density: 0.95,
                        buildingTypes: ['skyscraper', 'office_tower', 'bank']
                    },
                    downtown: { 
                        name: 'Downtown', 
                        color: 0x283593, 
                        buildingHeight: { min: 25, max: 55 }, 
                        density: 0.9,
                        buildingTypes: ['office', 'hotel', 'mixed_use', 'skyscraper']
                    },
                    commercial: { 
                        name: 'Commercial', 
                        color: 0x00acc1, 
                        buildingHeight: { min: 8, max: 25 }, 
                        density: 0.8,
                        buildingTypes: ['shopping', 'mall', 'office', 'store']
                    },
                    midtown: { 
                        name: 'Midtown', 
                        color: 0x0097a7, 
                        buildingHeight: { min: 15, max: 35 }, 
                        density: 0.85,
                        buildingTypes: ['apartment_tower', 'office', 'mixed_use']
                    },
                    cultural: { 
                        name: 'Cultural', 
                        color: 0x6a1b9a, 
                        buildingHeight: { min: 5, max: 20 }, 
                        density: 0.65,
                        buildingTypes: ['museum', 'theater', 'gallery', 'library']
                    },
                    university: { 
                        name: 'University', 
                        color: 0x1565c0, 
                        buildingHeight: { min: 8, max: 25 }, 
                        density: 0.7,
                        buildingTypes: ['academic', 'dormitory', 'library']
                    },
                    medical: { 
                        name: 'Medical', 
                        color: 0xe8f5e9, 
                        buildingHeight: { min: 10, max: 30 }, 
                        density: 0.7,
                        buildingTypes: ['hospital', 'clinic', 'medical_office']
                    },
                    residential_high: { 
                        name: 'High-Rise Residential', 
                        color: 0x4e342e, 
                        buildingHeight: { min: 15, max: 40 }, 
                        density: 0.85,
                        buildingTypes: ['luxury_apartment', 'condo_tower']
                    },
                    residential_mid: { 
                        name: 'Mid-Rise Residential', 
                        color: 0x5d4037, 
                        buildingHeight: { min: 6, max: 15 }, 
                        density: 0.75,
                        buildingTypes: ['apartment', 'condo']
                    },
                    residential_low: { 
                        name: 'Low Residential', 
                        color: 0x6d4c41, 
                        buildingHeight: { min: 1, max: 4 }, 
                        density: 0.6,
                        buildingTypes: ['house', 'townhouse', 'duplex']
                    },
                    historic: { 
                        name: 'Historic', 
                        color: 0x8d6e63, 
                        buildingHeight: { min: 3, max: 12 }, 
                        density: 0.65,
                        buildingTypes: ['historic', 'brownstone', 'victorian']
                    },
                    industrial: { 
                        name: 'Industrial', 
                        color: 0x424242, 
                        buildingHeight: { min: 5, max: 15 }, 
                        density: 0.5,
                        buildingTypes: ['factory', 'warehouse', 'industrial']
                    },
                    suburban: { 
                        name: 'Suburban', 
                        color: 0x795548, 
                        buildingHeight: { min: 1, max: 3 }, 
                        density: 0.4,
                        buildingTypes: ['suburban_house', 'bungalow']
                    }
                };
                
                // Create district zones with realistic city planning
                this.districts = [];
                for (let x = -this.citySize; x < this.citySize; x += this.blockSize) {
                    for (let z = -this.citySize; z < this.citySize; z += this.blockSize) {
                        const distFromCenter = Math.sqrt(x * x + z * z);
                        const normalizedDist = distFromCenter / this.citySize;
                        const angle = Math.atan2(z, x);
                        const noise = this.simplex.noise2D(x * 0.03, z * 0.03);
                        
                        let districtType;
                        
                        // Create realistic city zones based on distance and angle
                        if (normalizedDist < 0.15) {
                            // City core - financial district
                            districtType = this.districtTypes.financial;
                        } else if (normalizedDist < 0.25) {
                            // Downtown area
                            if (Math.random() < 0.7) {
                                districtType = this.districtTypes.downtown;
                            } else {
                                districtType = this.districtTypes.midtown;
                            }
                        } else if (normalizedDist < 0.4) {
                            // Inner city - mixed use
                            const rand = Math.random();
                            if (rand < 0.3) {
                                districtType = this.districtTypes.commercial;
                            } else if (rand < 0.5) {
                                districtType = this.districtTypes.midtown;
                            } else if (rand < 0.7) {
                                districtType = this.districtTypes.residential_high;
                            } else if (rand < 0.85) {
                                districtType = this.districtTypes.cultural;
                            } else {
                                districtType = this.districtTypes.university;
                            }
                        } else if (normalizedDist < 0.6) {
                            // Mid city - primarily residential
                            const rand = Math.random();
                            if (rand < 0.5) {
                                districtType = this.districtTypes.residential_mid;
                            } else if (rand < 0.7) {
                                districtType = this.districtTypes.residential_low;
                            } else if (rand < 0.85) {
                                districtType = this.districtTypes.commercial;
                            } else if (rand < 0.95) {
                                districtType = this.districtTypes.historic;
                            } else {
                                districtType = this.districtTypes.medical;
                            }
                        } else if (normalizedDist < 0.8) {
                            // Outer city
                            const rand = Math.random();
                            if (angle > -Math.PI/4 && angle < Math.PI/4 && rand < 0.4) {
                                // Industrial zone on one side
                                districtType = this.districtTypes.industrial;
                            } else if (rand < 0.7) {
                                districtType = this.districtTypes.residential_low;
                            } else {
                                districtType = this.districtTypes.suburban;
                            }
                        } else {
                            // Suburbs
                            districtType = this.districtTypes.suburban;
                        }
                        
                        this.districts.push({
                            x: x,
                            z: z,
                            width: this.blockSize,
                            height: this.blockSize,
                            type: districtType
                        });
                    }
                }
            }
            
            generateRoads() {
                const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
                const lineMarkingMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const sidewalkMaterial = new THREE.MeshLambertMaterial({ color: 0x9e9e9e });
                
                // Create road grid
                for (let i = -this.citySize; i <= this.citySize; i += this.blockSize) {
                    // Horizontal roads
                    const hRoad = new THREE.Mesh(
                        new THREE.BoxGeometry(this.citySize * 2, 0.1, 2.5),
                        roadMaterial
                    );
                    hRoad.position.set(0, 0.05, i);
                    hRoad.receiveShadow = true;
                    this.scene.add(hRoad);
                    this.roads.push(hRoad);
                    
                    // Vertical roads
                    const vRoad = new THREE.Mesh(
                        new THREE.BoxGeometry(2.5, 0.1, this.citySize * 2),
                        roadMaterial
                    );
                    vRoad.position.set(i, 0.05, 0);
                    vRoad.receiveShadow = true;
                    this.scene.add(vRoad);
                    this.roads.push(vRoad);
                    
                    // Add sidewalks
                    const hSidewalk1 = new THREE.Mesh(
                        new THREE.BoxGeometry(this.citySize * 2, 0.08, 0.8),
                        sidewalkMaterial
                    );
                    hSidewalk1.position.set(0, 0.06, i + 1.65);
                    this.scene.add(hSidewalk1);
                    
                    const hSidewalk2 = new THREE.Mesh(
                        new THREE.BoxGeometry(this.citySize * 2, 0.08, 0.8),
                        sidewalkMaterial
                    );
                    hSidewalk2.position.set(0, 0.06, i - 1.65);
                    this.scene.add(hSidewalk2);
                    
                    // Road markings
                    if (i % (this.blockSize * 2) === 0) {
                        // Main road - add center line
                        for (let j = -this.citySize; j < this.citySize; j += 5) {
                            const marking = new THREE.Mesh(
                                new THREE.BoxGeometry(0.15, 0.11, 2),
                                lineMarkingMaterial
                            );
                            marking.position.set(j, 0.06, i);
                            this.scene.add(marking);
                        }
                    }
                }
                
                // Add intersections
                for (let x = -this.citySize; x <= this.citySize; x += this.blockSize) {
                    for (let z = -this.citySize; z <= this.citySize; z += this.blockSize) {
                        const intersection = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 0.1, 3),
                            roadMaterial
                        );
                        intersection.position.set(x, 0.05, z);
                        intersection.receiveShadow = true;
                        this.scene.add(intersection);
                    }
                }
            }
            
            generateParks() {
                this.parks = [];
                const parkMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x43a047,
                    side: THREE.DoubleSide
                });
                
                // Create parks of different sizes that fit the grid
                const parkConfigs = [
                    { blocks: 2, count: 2 }, // Large parks (2x2 blocks)
                    { blocks: 1, count: 5 }, // Medium parks (1x1 block)
                ];
                
                for (let config of parkConfigs) {
                    for (let i = 0; i < config.count; i++) {
                        // Find suitable location
                        let attempts = 0;
                        let placed = false;
                        
                        while (!placed && attempts < 50) {
                            const blockX = Math.floor(Math.random() * (this.citySize * 2 / this.blockSize - config.blocks));
                            const blockZ = Math.floor(Math.random() * (this.citySize * 2 / this.blockSize - config.blocks));
                            
                            const x = -this.citySize + blockX * this.blockSize + (config.blocks * this.blockSize) / 2;
                            const z = -this.citySize + blockZ * this.blockSize + (config.blocks * this.blockSize) / 2;
                            
                            // Check distance from center (don't place parks in financial district)
                            const distFromCenter = Math.sqrt(x * x + z * z);
                            if (distFromCenter < this.citySize * 0.2) {
                                attempts++;
                                continue;
                            }
                            
                            // Check if space is available
                            let available = true;
                            for (let park of this.parks) {
                                const dist = Math.sqrt(Math.pow(park.x - x, 2) + Math.pow(park.z - z, 2));
                                if (dist < (park.size + config.blocks * this.blockSize) / 2 + 5) {
                                    available = false;
                                    break;
                                }
                            }
                            
                            if (available) {
                                // Create park base
                                const parkSize = config.blocks * this.blockSize - 2;
                                const park = new THREE.Mesh(
                                    new THREE.PlaneGeometry(parkSize, parkSize),
                                    parkMaterial
                                );
                                park.rotation.x = -Math.PI / 2;
                                park.position.set(x, 0.11, z);
                                park.receiveShadow = true;
                                this.scene.add(park);
                                
                                // Mark districts as park areas
                                for (let dx = 0; dx < config.blocks; dx++) {
                                    for (let dz = 0; dz < config.blocks; dz++) {
                                        const districtX = -this.citySize + (blockX + dx) * this.blockSize;
                                        const districtZ = -this.citySize + (blockZ + dz) * this.blockSize;
                                        
                                        // Find and mark district as park
                                        for (let district of this.districts) {
                                            if (Math.abs(district.x - districtX) < 1 && Math.abs(district.z - districtZ) < 1) {
                                                district.isPark = true;
                                            }
                                        }
                                    }
                                }
                                
                                // Add park features
                                this.addParkFeatures(x, z, parkSize);
                                
                                this.parks.push({ x: x, z: z, size: parkSize });
                                placed = true;
                            }
                            attempts++;
                        }
                    }
                }
            }
            
            addParkFeatures(centerX, centerZ, size) {
                // Add trees
                const treeCount = Math.floor(size * size / 20);
                for (let i = 0; i < treeCount; i++) {
                    const tree = this.createTree();
                    const x = centerX + (Math.random() - 0.5) * (size - 2);
                    const z = centerZ + (Math.random() - 0.5) * (size - 2);
                    tree.position.set(x, 0, z);
                    this.scene.add(tree);
                }
                
                // Add benches
                const benchCount = Math.floor(size / 5);
                for (let i = 0; i < benchCount; i++) {
                    const bench = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.5, 0.8),
                        new THREE.MeshLambertMaterial({ color: 0x8d6e63 })
                    );
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * (size / 2 - 2);
                    bench.position.set(
                        centerX + Math.cos(angle) * radius,
                        0.25,
                        centerZ + Math.sin(angle) * radius
                    );
                    bench.rotation.y = angle;
                    this.scene.add(bench);
                }
                
                // Add fountain for large parks
                if (size > 15) {
                    const fountain = new THREE.Mesh(
                        new THREE.CylinderGeometry(2, 2.5, 0.5, 8),
                        new THREE.MeshLambertMaterial({ color: 0x90a4ae })
                    );
                    fountain.position.set(centerX, 0.25, centerZ);
                    this.scene.add(fountain);
                    
                    // Water effect
                    const water = new THREE.Mesh(
                        new THREE.CircleGeometry(1.8, 16),
                        new THREE.MeshBasicMaterial({ color: 0x4fc3f7, opacity: 0.7, transparent: true })
                    );
                    water.rotation.x = -Math.PI / 2;
                    water.position.set(centerX, 0.5, centerZ);
                    this.scene.add(water);
                }
            }
            
            generateBuildings() {
                this.population = 0;
                this.buildings = [];
                
                for (let district of this.districts) {
                    // Skip if district is marked as park
                    if (district.isPark) continue;
                    
                    // Calculate actual density based on district and slider
                    const actualDensity = district.type.density * this.buildingDensity;
                    
                    // Generate buildings to fill the block
                    this.fillDistrictWithBuildings(district, actualDensity);
                }
            }
            
            fillDistrictWithBuildings(district, density) {
                const margin = 1.5; // Distance from road edge
                const buildingSpacing = 0.3; // Minimum space between buildings
                
                // Available area within the block (accounting for roads)
                const availableWidth = district.width - margin * 2;
                const availableHeight = district.height - margin * 2;
                
                // Determine building layout based on district type
                if (district.type.buildingTypes.includes('skyscraper') && Math.random() < 0.3) {
                    // Single large building for skyscrapers
                    this.createLargeBuilding(district, availableWidth * 0.8, availableHeight * 0.8);
                } else {
                    // Grid of buildings
                    const buildingsPerSide = Math.floor(Math.sqrt(density * 16)); // Approximate buildings per block
                    const buildingSize = Math.min(
                        (availableWidth - buildingSpacing * (buildingsPerSide - 1)) / buildingsPerSide,
                        (availableHeight - buildingSpacing * (buildingsPerSide - 1)) / buildingsPerSide
                    );
                    
                    if (buildingSize > 1) { // Only create buildings if they're reasonably sized
                        for (let i = 0; i < buildingsPerSide; i++) {
                            for (let j = 0; j < buildingsPerSide; j++) {
                                if (Math.random() < density) {
                                    const x = district.x - availableWidth/2 + i * (buildingSize + buildingSpacing) + buildingSize/2;
                                    const z = district.z - availableHeight/2 + j * (buildingSize + buildingSpacing) + buildingSize/2;
                                    
                                    const buildingType = district.type.buildingTypes[
                                        Math.floor(Math.random() * district.type.buildingTypes.length)
                                    ];
                                    
                                    const building = this.createBuildingByType(x, z, district.type, buildingType, buildingSize);
                                    if (building) {
                                        this.buildings.push(building);
                                        this.scene.add(building);
                                        
                                        // Calculate population
                                        this.population += this.calculateBuildingPopulation(building.userData);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            createLargeBuilding(district, width, depth) {
                const x = district.x;
                const z = district.z;
                const buildingType = district.type.buildingTypes[0]; // Use primary type
                
                const building = this.createBuildingByType(x, z, district.type, buildingType, Math.max(width, depth));
                if (building) {
                    this.buildings.push(building);
                    this.scene.add(building);
                    this.population += this.calculateBuildingPopulation(building.userData);
                }
            }
            
            createBuildingByType(x, z, districtType, buildingType, maxSize) {
                const height = districtType.buildingHeight.min + 
                              Math.random() * (districtType.buildingHeight.max - districtType.buildingHeight.min);
                const width = Math.min(maxSize * (0.6 + Math.random() * 0.4), 8);
                const depth = Math.min(maxSize * (0.6 + Math.random() * 0.4), 8);
                
                const buildingGroup = new THREE.Group();
                let geometry, material;
                const baseColor = new THREE.Color(districtType.color);
                baseColor.offsetHSL(0, 0, Math.random() * 0.2 - 0.1);
                
                // Create different building styles based on type
                switch(buildingType) {
                    case 'skyscraper':
                        // Tall, modern skyscraper with setbacks
                        const segments = Math.floor(height / 15);
                        for (let i = 0; i <= segments; i++) {
                            const segmentHeight = i === segments ? height % 15 || 15 : 15;
                            const segmentWidth = width * (1 - i * 0.1);
                            const segmentDepth = depth * (1 - i * 0.1);
                            
                            geometry = new THREE.BoxGeometry(segmentWidth, segmentHeight, segmentDepth);
                            material = new THREE.MeshLambertMaterial({ 
                                color: baseColor,
                                emissive: baseColor,
                                emissiveIntensity: 0.02
                            });
                            
                            const segment = new THREE.Mesh(geometry, material);
                            segment.position.y = i * 15 + segmentHeight / 2;
                            segment.castShadow = true;
                            segment.receiveShadow = true;
                            buildingGroup.add(segment);
                        }
                        break;
                        
                    case 'office_tower':
                    case 'office':
                        // Modern office building
                        geometry = new THREE.BoxGeometry(width, height, depth);
                        material = new THREE.MeshPhongMaterial({ 
                            color: 0x37474f,
                            emissive: 0x37474f,
                            emissiveIntensity: 0.05,
                            shininess: 80
                        });
                        const office = new THREE.Mesh(geometry, material);
                        office.position.y = height / 2;
                        office.castShadow = true;
                        buildingGroup.add(office);
                        break;
                        
                    case 'apartment_tower':
                    case 'luxury_apartment':
                    case 'condo_tower':
                        // Residential tower with balconies
                        geometry = new THREE.BoxGeometry(width, height, depth);
                        material = new THREE.MeshLambertMaterial({ 
                            color: baseColor,
                            emissive: baseColor,
                            emissiveIntensity: 0.08
                        });
                        const tower = new THREE.Mesh(geometry, material);
                        tower.position.y = height / 2;
                        tower.castShadow = true;
                        buildingGroup.add(tower);
                        
                        // Add balconies
                        const balconyRows = Math.floor(height / 3);
                        for (let i = 1; i < balconyRows; i++) {
                            if (Math.random() < 0.7) {
                                const balcony = new THREE.Mesh(
                                    new THREE.BoxGeometry(width * 0.8, 0.2, 1),
                                    new THREE.MeshLambertMaterial({ color: 0x757575 })
                                );
                                balcony.position.set(0, i * 3, depth/2 + 0.5);
                                buildingGroup.add(balcony);
                            }
                        }
                        break;
                        
                    case 'house':
                    case 'suburban_house':
                        // Single family home
                        geometry = new THREE.BoxGeometry(width * 0.8, height, depth * 0.8);
                        material = new THREE.MeshLambertMaterial({ 
                            color: baseColor
                        });
                        const house = new THREE.Mesh(geometry, material);
                        house.position.y = height / 2;
                        house.castShadow = true;
                        buildingGroup.add(house);
                        
                        // Add roof
                        const roofGeometry = new THREE.ConeGeometry(Math.max(width, depth) * 0.6, height * 0.4, 4);
                        const roof = new THREE.Mesh(
                            roofGeometry,
                            new THREE.MeshLambertMaterial({ color: 0x5d4037 })
                        );
                        roof.position.y = height + height * 0.2;
                        roof.rotation.y = Math.PI / 4;
                        buildingGroup.add(roof);
                        
                        // Add chimney
                        const chimney = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, height * 0.5, 0.3),
                            new THREE.MeshLambertMaterial({ color: 0x3e2723 })
                        );
                        chimney.position.set(width * 0.25, height * 0.75, 0);
                        buildingGroup.add(chimney);
                        break;
                        
                    case 'hospital':
                    case 'medical_office':
                        // Medical building
                        geometry = new THREE.BoxGeometry(width, height, depth);
                        material = new THREE.MeshLambertMaterial({ 
                            color: 0xffffff,
                            emissive: 0xffffff,
                            emissiveIntensity: 0.02
                        });
                        const medical = new THREE.Mesh(geometry, material);
                        medical.position.y = height / 2;
                        medical.castShadow = true;
                        buildingGroup.add(medical);
                        
                        // Add red cross
                        const crossMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                        const crossH = new THREE.Mesh(new THREE.BoxGeometry(width * 0.5, 0.3, 0.2), crossMat);
                        const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, depth * 0.5), crossMat);
                        crossH.position.set(0, height + 1, 0);
                        crossV.position.set(0, height + 1, 0);
                        buildingGroup.add(crossH);
                        buildingGroup.add(crossV);
                        break;
                        
                    case 'factory':
                    case 'warehouse':
                        // Industrial building
                        geometry = new THREE.BoxGeometry(width * 1.5, height * 0.7, depth * 1.5);
                        material = new THREE.MeshLambertMaterial({ 
                            color: 0x455a64
                        });
                        const industrial = new THREE.Mesh(geometry, material);
                        industrial.position.y = height * 0.35;
                        industrial.castShadow = true;
                        buildingGroup.add(industrial);
                        
                        // Add smokestacks for factories
                        if (buildingType === 'factory') {
                            for (let i = 0; i < 2; i++) {
                                const stack = new THREE.Mesh(
                                    new THREE.CylinderGeometry(0.3, 0.4, height * 0.8),
                                    new THREE.MeshLambertMaterial({ color: 0x263238 })
                                );
                                stack.position.set(width * (i - 0.5) * 0.5, height * 0.4, 0);
                                buildingGroup.add(stack);
                            }
                        }
                        break;
                        
                    case 'shopping':
                    case 'mall':
                    case 'store':
                        // Commercial building
                        geometry = new THREE.BoxGeometry(width, height, depth);
                        material = new THREE.MeshLambertMaterial({ 
                            color: 0x00bcd4,
                            emissive: 0x00bcd4,
                            emissiveIntensity: 0.1
                        });
                        const shop = new THREE.Mesh(geometry, material);
                        shop.position.y = height / 2;
                        shop.castShadow = true;
                        buildingGroup.add(shop);
                        
                        // Add storefront
                        const storefront = new THREE.Mesh(
                            new THREE.BoxGeometry(width * 0.9, height * 0.3, 0.2),
                            new THREE.MeshBasicMaterial({ 
                                color: 0x80deea,
                                transparent: true,
                                opacity: 0.8
                            })
                        );
                        storefront.position.set(0, height * 0.15, depth/2 + 0.1);
                        buildingGroup.add(storefront);
                        break;
                        
                    case 'museum':
                    case 'theater':
                    case 'library':
                        // Cultural building with unique architecture
                        if (buildingType === 'museum') {
                            // Museum with columns
                            geometry = new THREE.BoxGeometry(width, height, depth);
                            material = new THREE.MeshLambertMaterial({ color: 0xbcaaa4 });
                            const museum = new THREE.Mesh(geometry, material);
                            museum.position.y = height / 2;
                            museum.castShadow = true;
                            buildingGroup.add(museum);
                            
                            // Add columns
                            for (let i = 0; i < 4; i++) {
                                const column = new THREE.Mesh(
                                    new THREE.CylinderGeometry(0.3, 0.3, height * 0.8),
                                    new THREE.MeshLambertMaterial({ color: 0xd7ccc8 })
                                );
                                column.position.set(
                                    (i - 1.5) * width / 4,
                                    height * 0.4,
                                    depth/2 + 0.5
                                );
                                buildingGroup.add(column);
                            }
                        } else {
                            // Default cultural building
                            geometry = new THREE.BoxGeometry(width, height, depth);
                            material = new THREE.MeshLambertMaterial({ 
                                color: baseColor
                            });
                            const cultural = new THREE.Mesh(geometry, material);
                            cultural.position.y = height / 2;
                            cultural.castShadow = true;
                            buildingGroup.add(cultural);
                        }
                        break;
                        
                    default:
                        // Generic building
                        geometry = new THREE.BoxGeometry(width, height, depth);
                        material = new THREE.MeshLambertMaterial({ 
                            color: baseColor,
                            emissive: baseColor,
                            emissiveIntensity: 0.05
                        });
                        const generic = new THREE.Mesh(geometry, material);
                        generic.position.y = height / 2;
                        generic.castShadow = true;
                        buildingGroup.add(generic);
                }
                
                // Add windows to most building types
                this.addWindowsToBuilding(buildingGroup, width, height, depth, buildingType);
                
                // Add roof details for tall buildings
                if (height > 25 && (buildingType === 'skyscraper' || buildingType === 'office_tower')) {
                    this.addRooftopDetails(buildingGroup, height);
                }
                
                buildingGroup.position.set(x, 0, z);
                buildingGroup.userData = { 
                    height: height, 
                    type: buildingType,
                    district: districtType.name,
                    width: width,
                    depth: depth
                };
                
                return buildingGroup;
            }
            
            addWindowsToBuilding(buildingGroup, width, height, depth, buildingType) {
                // Skip windows for certain building types
                if (['factory', 'warehouse'].includes(buildingType)) return;
                
                const windowRows = Math.floor(height / 2.5);
                const windowCols = Math.floor(width);
                const windowSize = buildingType === 'skyscraper' ? 0.8 : 0.5;
                
                for (let row = 0; row < windowRows; row++) {
                    for (let col = 0; col < windowCols; col++) {
                        const lit = Math.random() > 0.3;
                        const windowColor = lit ? 0xffd700 : 0x1a237e;
                        
                        const window = new THREE.Mesh(
                            new THREE.BoxGeometry(windowSize, windowSize, 0.1),
                            new THREE.MeshBasicMaterial({ 
                                color: windowColor,
                                emissive: windowColor,
                                emissiveIntensity: lit ? 0.8 : 0.2
                            })
                        );
                        window.position.set(
                            (col - windowCols / 2) * 0.9 + 0.45,
                            row * 2.5 + 1.5,
                            depth / 2 + 0.05
                        );
                        buildingGroup.add(window);
                        
                        if (lit) this.lights.push(window);
                    }
                }
            }
            
            addRooftopDetails(buildingGroup, height) {
                // Antenna
                const antenna = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, height * 0.15),
                    new THREE.MeshBasicMaterial({ color: 0x666666 })
                );
                antenna.position.y = height + height * 0.075;
                buildingGroup.add(antenna);
                
                // Warning light
                const warningLight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 6, 6),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xff0000, 
                        emissive: 0xff0000,
                        emissiveIntensity: 1
                    })
                );
                warningLight.position.y = height + height * 0.15;
                buildingGroup.add(warningLight);
                this.lights.push(warningLight);
                
                // Helipad for very tall buildings
                if (height > 40) {
                    const helipad = new THREE.Mesh(
                        new THREE.CircleGeometry(2, 8),
                        new THREE.MeshLambertMaterial({ color: 0x37474f })
                    );
                    helipad.rotation.x = -Math.PI / 2;
                    helipad.position.y = height + 0.1;
                    buildingGroup.add(helipad);
                    
                    // H marking
                    const hMark = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 0.05, 0.2),
                        new THREE.MeshBasicMaterial({ color: 0xffffff })
                    );
                    hMark.position.y = height + 0.11;
                    buildingGroup.add(hMark);
                }
            }
            
            calculateBuildingPopulation(buildingData) {
                const volume = buildingData.height * (buildingData.width || 3) * (buildingData.depth || 3);
                const type = buildingData.type;
                
                let populationDensity;
                switch(type) {
                    case 'house':
                    case 'suburban_house':
                    case 'bungalow':
                        populationDensity = 0.5; // Low density
                        break;
                    case 'apartment':
                    case 'apartment_tower':
                    case 'condo':
                    case 'condo_tower':
                    case 'luxury_apartment':
                        populationDensity = 2; // High density
                        break;
                    case 'office':
                    case 'office_tower':
                    case 'skyscraper':
                        populationDensity = 1; // Workers
                        break;
                    case 'hospital':
                    case 'medical_office':
                        populationDensity = 0.8;
                        break;
                    case 'shopping':
                    case 'mall':
                    case 'store':
                        populationDensity = 0.3;
                        break;
                    default:
                        populationDensity = 0.5;
                }
                
                return Math.floor(volume * populationDensity);
            }
            
            createTree() {
                const treeGroup = new THREE.Group();
                
                // Trunk
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.2, 1.5),
                    new THREE.MeshLambertMaterial({ color: 0x5d4037 })
                );
                trunk.position.y = 0.75;
                trunk.castShadow = true;
                treeGroup.add(trunk);
                
                // Leaves - varied shapes
                const leafType = Math.random();
                let leaves;
                if (leafType < 0.5) {
                    // Round tree
                    leaves = new THREE.Mesh(
                        new THREE.SphereGeometry(1.2, 6, 5),
                        new THREE.MeshLambertMaterial({ color: 0x2e7d32 })
                    );
                    leaves.position.y = 2.2;
                } else {
                    // Cone tree
                    leaves = new THREE.Mesh(
                        new THREE.ConeGeometry(1, 2, 6),
                        new THREE.MeshLambertMaterial({ color: 0x1b5e20 })
                    );
                    leaves.position.y = 2.5;
                }
                leaves.castShadow = true;
                treeGroup.add(leaves);
                
                return treeGroup;
            }
            
            generateVehicles() {
                this.vehicles = [];
                const numVehicles = parseInt(document.getElementById('trafficDensity').value);
                
                for (let i = 0; i < numVehicles; i++) {
                    const vehicle = this.createVehicle();
                    this.vehicles.push(vehicle);
                    this.scene.add(vehicle);
                }
            }
            
            generatePedestrians() {
                this.pedestrians = [];
                const numPedestrians = Math.floor(this.population / 100); // 1% of population visible
                
                for (let i = 0; i < Math.min(numPedestrians, 200); i++) { // Cap at 200 for performance
                    const pedestrian = this.createPedestrian();
                    this.pedestrians.push(pedestrian);
                    this.scene.add(pedestrian);
                }
            }
            
            createVehicle() {
                const vehicleGroup = new THREE.Group();
                
                // Different vehicle types
                const vehicleType = Math.random();
                let bodyColor = new THREE.Color().setHSL(Math.random(), 0.7, 0.5);
                
                if (vehicleType < 0.7) {
                    // Car
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.7, 0.9),
                        new THREE.MeshLambertMaterial({ color: bodyColor })
                    );
                    body.position.y = 0.35;
                    body.castShadow = true;
                    vehicleGroup.add(body);
                    
                    const roof = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 0.4, 0.7),
                        new THREE.MeshLambertMaterial({ color: bodyColor })
                    );
                    roof.position.y = 0.8;
                    vehicleGroup.add(roof);
                } else if (vehicleType < 0.9) {
                    // Bus
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 1.2, 0.9),
                        new THREE.MeshLambertMaterial({ color: 0xff9800 })
                    );
                    body.position.y = 0.6;
                    body.castShadow = true;
                    vehicleGroup.add(body);
                } else {
                    // Truck
                    const cab = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 0.8, 0.9),
                        new THREE.MeshLambertMaterial({ color: 0x795548 })
                    );
                    cab.position.set(-0.5, 0.4, 0);
                    cab.castShadow = true;
                    vehicleGroup.add(cab);
                    
                    const cargo = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 1, 0.9),
                        new THREE.MeshLambertMaterial({ color: 0x616161 })
                    );
                    cargo.position.set(0.5, 0.5, 0);
                    cargo.castShadow = true;
                    vehicleGroup.add(cargo);
                }
                
                // Headlights
                const headlight = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.2, 0.1),
                    new THREE.MeshBasicMaterial({ color: 0xffff00 })
                );
                headlight.position.set(0.3, 0.3, 0.5);
                vehicleGroup.add(headlight);
                
                // Set initial position
                const roadIndex = Math.floor(Math.random() * this.roads.length);
                const road = this.roads[roadIndex];
                
                vehicleGroup.position.copy(road.position);
                vehicleGroup.position.y = 0.15;
                
                vehicleGroup.userData = {
                    speed: 0.05 + Math.random() * 0.15,
                    direction: Math.random() > 0.5 ? 1 : -1,
                    axis: roadIndex % 2 === 0 ? 'x' : 'z',
                    targetLane: road.position
                };
                
                return vehicleGroup;
            }
            
            createPedestrian() {
                const pedestrianGroup = new THREE.Group();
                
                // Body colors
                const clothingColor = new THREE.Color().setHSL(Math.random(), 0.5, 0.3);
                
                // Body
                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12, 0.12, 0.6),
                    new THREE.MeshLambertMaterial({ color: clothingColor })
                );
                body.position.y = 0.3;
                body.castShadow = true;
                pedestrianGroup.add(body);
                
                // Head
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.12, 6, 6),
                    new THREE.MeshLambertMaterial({ color: 0xfdbcb4 })
                );
                head.position.y = 0.72;
                pedestrianGroup.add(head);
                
                // Legs
                const leg1 = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 0.4),
                    new THREE.MeshLambertMaterial({ color: 0x1a237e })
                );
                leg1.position.set(0.05, 0.2, 0);
                pedestrianGroup.add(leg1);
                
                const leg2 = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 0.4),
                    new THREE.MeshLambertMaterial({ color: 0x1a237e })
                );
                leg2.position.set(-0.05, 0.2, 0);
                pedestrianGroup.add(leg2);
                
                // Set initial position on sidewalk
                const side = Math.random() > 0.5 ? 1.9 : -1.9;
                const axis = Math.random() > 0.5 ? 'x' : 'z';
                
                if (axis === 'x') {
                    pedestrianGroup.position.x = (Math.random() - 0.5) * this.citySize * 2;
                    pedestrianGroup.position.z = Math.floor(Math.random() * 10) * 10 + side;
                } else {
                    pedestrianGroup.position.z = (Math.random() - 0.5) * this.citySize * 2;
                    pedestrianGroup.position.x = Math.floor(Math.random() * 10) * 10 + side;
                }
                
                pedestrianGroup.position.y = 0;
                
                pedestrianGroup.userData = {
                    speed: 0.015 + Math.random() * 0.025,
                    direction: Math.random() > 0.5 ? 1 : -1,
                    axis: axis,
                    walkPhase: Math.random() * Math.PI * 2,
                    state: 'walking'
                };
                
                return pedestrianGroup;
            }
            
            updateVehicles() {
                if (!this.trafficEnabled) return;
                
                for (let vehicle of this.vehicles) {
                    const data = vehicle.userData;
                    
                    // Move vehicle
                    if (data.axis === 'x') {
                        vehicle.position.x += data.speed * data.direction * this.simulationSpeed;
                        vehicle.rotation.y = data.direction > 0 ? Math.PI / 2 : -Math.PI / 2;
                        
                        // Wrap around city
                        if (Math.abs(vehicle.position.x) > this.citySize) {
                            vehicle.position.x = -vehicle.position.x;
                        }
                    } else {
                        vehicle.position.z += data.speed * data.direction * this.simulationSpeed;
                        vehicle.rotation.y = data.direction > 0 ? 0 : Math.PI;
                        
                        // Wrap around city
                        if (Math.abs(vehicle.position.z) > this.citySize) {
                            vehicle.position.z = -vehicle.position.z;
                        }
                    }
                    
                    // Random lane changes at intersections
                    if (Math.random() < 0.002) {
                        data.direction *= -1;
                    }
                }
            }
            
            updatePedestrians() {
                if (!this.simulationRunning) return;
                
                for (let pedestrian of this.pedestrians) {
                    const data = pedestrian.userData;
                    
                    // Walking animation
                    pedestrian.position.y = Math.abs(Math.sin(Date.now() * 0.005 + data.walkPhase)) * 0.05;
                    
                    // Leg animation
                    if (pedestrian.children[2] && pedestrian.children[3]) {
                        pedestrian.children[2].rotation.x = Math.sin(Date.now() * 0.005 + data.walkPhase) * 0.3;
                        pedestrian.children[3].rotation.x = -Math.sin(Date.now() * 0.005 + data.walkPhase) * 0.3;
                    }
                    
                    // Move pedestrian
                    if (data.state === 'walking') {
                        if (data.axis === 'x') {
                            pedestrian.position.x += data.speed * data.direction * this.simulationSpeed;
                            pedestrian.rotation.y = data.direction > 0 ? Math.PI / 2 : -Math.PI / 2;
                            
                            if (Math.abs(pedestrian.position.x) > this.citySize) {
                                pedestrian.position.x = -pedestrian.position.x;
                            }
                        } else {
                            pedestrian.position.z += data.speed * data.direction * this.simulationSpeed;
                            pedestrian.rotation.y = data.direction > 0 ? 0 : Math.PI;
                            
                            if (Math.abs(pedestrian.position.z) > this.citySize) {
                                pedestrian.position.z = -pedestrian.position.z;
                            }
                        }
                    }
                    
                    // Random behavior changes
                    if (Math.random() < 0.002) {
                        const rand = Math.random();
                        if (rand < 0.3) {
                            data.direction *= -1;
                        } else if (rand < 0.5) {
                            data.state = data.state === 'walking' ? 'waiting' : 'walking';
                        }
                    }
                }
            }
            
            updateEnvironment() {
                // Update time of day
                if (this.dayNightCycle) {
                    this.timeOfDay += 0.01 * this.simulationSpeed;
                    if (this.timeOfDay > 24) this.timeOfDay = 0;
                    document.getElementById('timeOfDay').value = this.timeOfDay;
                }
                
                // Calculate sun position based on time
                const sunAngle = (this.timeOfDay / 24) * Math.PI * 2 - Math.PI / 2;
                this.sunLight.position.x = Math.cos(sunAngle) * 100;
                this.sunLight.position.y = Math.sin(sunAngle) * 100 + 50;
                
                // Adjust lighting based on time
                const dayIntensity = Math.max(0, Math.sin(sunAngle));
                const nightIntensity = 1 - dayIntensity;
                
                this.sunLight.intensity = dayIntensity;
                this.ambientLight.intensity = 0.2 + dayIntensity * 0.4;
                
                // Update sky color
                const skyColor = new THREE.Color();
                if (dayIntensity > 0.5) {
                    skyColor.setHSL(0.6, 0.5, 0.6); // Day sky
                } else if (dayIntensity > 0) {
                    skyColor.setHSL(0.05, 0.7, 0.3); // Sunset/sunrise
                } else {
                    skyColor.setHSL(0.6, 0.5, 0.05); // Night sky
                }
                this.scene.fog.color = skyColor;
                this.renderer.setClearColor(skyColor);
                
                // Update building lights based on time
                for (let light of this.lights) {
                    light.visible = nightIntensity > 0.3 || this.weather === 'fog';
                }
                
                // Weather effects
                this.updateWeather();
                
                // Update display
                const hours = Math.floor(this.timeOfDay);
                const minutes = Math.floor((this.timeOfDay - hours) * 60);
                document.getElementById('timeValue').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                document.getElementById('currentTime').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            }
            
            updateWeather() {
                // Remove existing weather particles
                for (let particle of this.particles) {
                    this.scene.remove(particle);
                }
                this.particles = [];
                
                const weather = document.getElementById('weather').value;
                
                if (weather === 'rain') {
                    this.createRain();
                    this.scene.fog.near = 20;
                    this.scene.fog.far = 200;
                } else if (weather === 'snow') {
                    this.createSnow();
                    this.scene.fog.near = 10;
                    this.scene.fog.far = 150;
                } else if (weather === 'fog') {
                    this.scene.fog.near = 5;
                    this.scene.fog.far = 100;
                } else {
                    this.scene.fog.near = 50;
                    this.scene.fog.far = 300;
                }
            }
            
            createRain() {
                const rainGeometry = new THREE.BufferGeometry();
                const rainCount = 1000;
                const positions = new Float32Array(rainCount * 3);
                
                for (let i = 0; i < rainCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 200;
                    positions[i + 1] = Math.random() * 100;
                    positions[i + 2] = (Math.random() - 0.5) * 200;
                }
                
                rainGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const rainMaterial = new THREE.PointsMaterial({
                    color: 0xaaaaff,
                    size: 0.3,
                    transparent: true,
                    opacity: 0.6
                });
                
                const rain = new THREE.Points(rainGeometry, rainMaterial);
                rain.userData = { type: 'rain' };
                this.particles.push(rain);
                this.scene.add(rain);
            }
            
            createSnow() {
                const snowGeometry = new THREE.BufferGeometry();
                const snowCount = 500;
                const positions = new Float32Array(snowCount * 3);
                
                for (let i = 0; i < snowCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 200;
                    positions[i + 1] = Math.random() * 100;
                    positions[i + 2] = (Math.random() - 0.5) * 200;
                }
                
                snowGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const snowMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 1,
                    transparent: true,
                    opacity: 0.8
                });
                
                const snow = new THREE.Points(snowGeometry, snowMaterial);
                snow.userData = { type: 'snow' };
                this.particles.push(snow);
                this.scene.add(snow);
            }
            
            updateParticles() {
                for (let particleSystem of this.particles) {
                    const positions = particleSystem.geometry.attributes.position.array;
                    
                    if (particleSystem.userData.type === 'rain') {
                        for (let i = 1; i < positions.length; i += 3) {
                            positions[i] -= 2;
                            if (positions[i] < 0) {
                                positions[i] = 100;
                            }
                        }
                    } else if (particleSystem.userData.type === 'snow') {
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                            positions[i + 1] -= 0.3;
                            if (positions[i + 1] < 0) {
                                positions[i + 1] = 100;
                            }
                        }
                    }
                    
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                }
            }
            
            setupControls() {
                // Mouse controls
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    this.mouse.isDown = true;
                    this.mouse.button = e.button;
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });
                
                this.renderer.domElement.addEventListener('mouseup', () => {
                    this.mouse.isDown = false;
                });
                
                this.renderer.domElement.addEventListener('mousemove', (e) => {
                    if (this.mouse.isDown) {
                        const deltaX = e.clientX - this.mouse.x;
                        const deltaY = e.clientY - this.mouse.y;
                        
                        if (this.mouse.button === 0) { // Left click - rotate
                            this.cameraAngle -= deltaX * 0.01;
                            this.cameraHeight = Math.max(10, Math.min(150, this.cameraHeight - deltaY * 0.5));
                        } else if (this.mouse.button === 2) { // Right click - pan
                            this.cameraTarget.x -= deltaX * 0.2;
                            this.cameraTarget.z -= deltaY * 0.2;
                        }
                        
                        this.mouse.x = e.clientX;
                        this.mouse.y = e.clientY;
                    }
                });
                
                // Prevent context menu
                this.renderer.domElement.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                
                // Wheel for zoom
                this.renderer.domElement.addEventListener('wheel', (e) => {
                    this.cameraDistance = Math.max(30, Math.min(200, this.cameraDistance + e.deltaY * 0.1));
                });
                
                // Keyboard controls
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
            }
            
            updateCamera() {
                // Keyboard movement
                const moveSpeed = 1;
                if (this.keys['w'] || this.keys['arrowup']) this.cameraTarget.z -= moveSpeed;
                if (this.keys['s'] || this.keys['arrowdown']) this.cameraTarget.z += moveSpeed;
                if (this.keys['a'] || this.keys['arrowleft']) this.cameraTarget.x -= moveSpeed;
                if (this.keys['d'] || this.keys['arrowright']) this.cameraTarget.x += moveSpeed;
                
                // Update camera position based on mode
                if (this.cameraMode === 'orbit') {
                    this.camera.position.x = this.cameraTarget.x + Math.cos(this.cameraAngle) * this.cameraDistance;
                    this.camera.position.y = this.cameraHeight;
                    this.camera.position.z = this.cameraTarget.z + Math.sin(this.cameraAngle) * this.cameraDistance;
                    this.camera.lookAt(this.cameraTarget);
                } else if (this.cameraMode === 'topdown') {
                    this.camera.position.x = this.cameraTarget.x;
                    this.camera.position.y = this.cameraDistance;
                    this.camera.position.z = this.cameraTarget.z;
                    this.camera.lookAt(this.cameraTarget);
                }
            }
            
            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Control sliders
                document.getElementById('citySize').addEventListener('input', (e) => {
                    this.citySize = parseInt(e.target.value);
                    document.getElementById('sizeValue').textContent = this.citySize;
                });
                
                document.getElementById('density').addEventListener('input', (e) => {
                    this.buildingDensity = parseFloat(e.target.value);
                    document.getElementById('densityValue').textContent = this.buildingDensity;
                });
                
                document.getElementById('timeOfDay').addEventListener('input', (e) => {
                    this.timeOfDay = parseFloat(e.target.value);
                    this.dayNightCycle = false;
                });
                
                document.getElementById('trafficDensity').addEventListener('input', (e) => {
                    document.getElementById('trafficValue').textContent = e.target.value;
                    this.generateVehicles();
                });
                
                document.getElementById('simSpeed').addEventListener('input', (e) => {
                    this.simulationSpeed = parseFloat(e.target.value);
                    document.getElementById('speedValue').textContent = this.simulationSpeed + 'x';
                });
                
                document.getElementById('weather').addEventListener('change', () => {
                    this.updateWeather();
                });
            }
            
            clearCity() {
                // Remove all objects
                while(this.scene.children.length > 0) {
                    this.scene.remove(this.scene.children[0]);
                }
                
                this.buildings = [];
                this.vehicles = [];
                this.pedestrians = [];
                this.roads = [];
                this.lights = [];
                this.particles = [];
                this.parks = [];
                
                // Re-add lighting
                this.setupLighting();
            }
            
            generateNewCity() {
                document.getElementById('loading').style.display = 'block';
                setTimeout(() => {
                    this.generateCity();
                    document.getElementById('loading').style.display = 'none';
                }, 100);
            }
            
            toggleSimulation() {
                this.simulationRunning = !this.simulationRunning;
            }
            
            toggleDayNightCycle() {
                this.dayNightCycle = !this.dayNightCycle;
            }
            
            toggleTraffic() {
                this.trafficEnabled = !this.trafficEnabled;
            }
            
            toggleCameraMode() {
                this.cameraMode = this.cameraMode === 'orbit' ? 'topdown' : 'orbit';
                if (this.cameraMode === 'topdown') {
                    this.camera.rotation.x = -Math.PI / 2;
                }
            }
            
            resetCamera() {
                this.cameraAngle = 0;
                this.cameraDistance = 100;
                this.cameraHeight = 50;
                this.cameraTarget.set(0, 0, 0);
            }
            
            updateStats() {
                document.getElementById('population').textContent = 
                    this.population.toLocaleString();
                document.getElementById('buildingCount').textContent = 
                    this.buildings.length;
                document.getElementById('vehicleCount').textContent = 
                    this.vehicles.length + ' / ' + this.pedestrians.length + ' pedestrians';
                document.getElementById('economy').textContent = 
                    Math.floor(this.economicActivity + Math.sin(Date.now() * 0.001) * 5);
                
                // Update district info based on camera position
                const camX = this.camera.position.x;
                const camZ = this.camera.position.z;
                let closestDistrict = 'Downtown';
                let minDist = Infinity;
                
                for (let district of this.districts) {
                    const dist = Math.sqrt(
                        Math.pow(camX - district.x, 2) + 
                        Math.pow(camZ - district.z, 2)
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        closestDistrict = district.type.name;
                    }
                }
                
                document.getElementById('currentDistrict').textContent = closestDistrict;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const deltaTime = this.clock.getDelta();
                const elapsedTime = this.clock.getElapsedTime();
                
                // Calculate FPS
                if (elapsedTime - this.lastTime > 1) {
                    this.fps = Math.round(1 / deltaTime);
                    document.getElementById('fps').textContent = this.fps;
                    this.lastTime = elapsedTime;
                }
                
                if (this.simulationRunning) {
                    this.updateVehicles();
                    this.updatePedestrians();
                    this.updateEnvironment();
                    this.updateParticles();
                    this.updateStats();
                }
                
                this.updateCamera();
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize city generator
        const cityGen = new CityGenerator();
    </script>
</body>
</html>